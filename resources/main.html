<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="initial-scale=1, user-scalable=0, interactive-widget=resizes-content" />
<title>WebShuSH</title>
<link rel=stylesheet href="/resources/deps/xterm.css"
	integrity="sha384-LJcOxlx9IMbNXDqJ2axpfEQKkAYbFjJfhXexLfiRJhjDU81mzgkiQq8rkV0j6dVh" />
<script nonce="{{.Nonce}}">
	// Temporarily hide Macs from xtermjs loading to avoid it forcing Mac-style controls.
	// See: https://github.com/xtermjs/xterm.js/issues/4329
	_plt = navigator.platform
	navigator.__defineGetter__('platform', () => _plt.indexOf('Mac') == 0 ? 'nixLinux' : _plt)
</script>
<script src="/resources/deps/xterm.js"
	integrity="sha384-/nfmYPUzWMS6v2atn8hbljz7NE0EI1iGx34lJaNzyVjWGDzMv+ciUZUeJpKA3Glc"></script>
<script nonce="{{.Nonce}}">navigator.__defineGetter__('platform', () => _plt)</script>
<script src="/resources/deps/xterm-addon-fit.js"
	integrity="sha384-AQLWHRKAgdTxkolJcLOELg4E9rE89CPE2xMy3tIRFn08NcGKPTsELdvKomqji+DL"></script>
<style nonce="{{.Nonce}}">
	@font-face {
		font-family: NotoMonoNerd;
		src: url("/resources/NotoMonoNerdFontMono-Regular.ttf");
	}

	:root {
		color-scheme: light dark;
		--term-font: NotoMonoNerd;
	}

	* {
		font-family: system-ui, NotoMonoNerd;
	}

	body {
		/* UI pane with no page scrolling */
		position: fixed;
		margin: 0px;
		width: 100%;
		height: 100%;
		display: flex;
		overscroll-behavior: contain;
	}

	body>div>span {
		/* xtermjs font warmer fix so font width calculations are correct */
		font-family: var(--term-font);
	}
</style>

<body>
	<div><span><!-- xtermjs font warmer --></span></div>
</body>

<!--
	-- Terminal window.
	-->
<template id=-terminal-window>
	<style nonce="{{.Nonce}}">
		#render {
			position: fixed;
			left: 0px;
			top: 0px;
			width: 100%;
			height: 100%;
			font-family: var(--term-font);
		}
	</style>
	<link rel=stylesheet href="/resources/deps/xterm.css"
		integrity="sha384-LJcOxlx9IMbNXDqJ2axpfEQKkAYbFjJfhXexLfiRJhjDU81mzgkiQq8rkV0j6dVh" />
	<div id=render></div>
</template>

<!--
	-- Login form
	-->
<template id=-login-form>
	<style nonce="{{.Nonce}}">
		:host {
			position: fixed;
			z-index: 999999;
		}

		div {
			display: flex;
			width: 100vw;
			height: 100vh;
			align-items: center;
			justify-content: center;
		}

		ul {
			list-style: none;
		}

		li {
			margin: 3px;
		}

		label {
			display: inline-block;
			width: 80px;
			text-align: right;
		}

		input {
			padding: 5px;
		}

		button {
			float: right;
			font-size: 2em;
			border-style: solid;
			border-color: currentColor;
			background-color: background;
		}

		button.loading {
			filter: blur(3px);
		}
	</style>
	<div tabindex="-1">
		<form>
			<h1>🖥 SSH</h1>
			<ul>
				<li>
					<label for=username>username</label>
					<input type=text id=username name=username required />
				</li>
				<li>
					<label for=password>password</label>
					<input type=password id=password name=password required />
				</li>
				<li>
					<label for=code></label>
					<input type=text id=code name=code title="2FA access code (optional on some servers)" size=6
						autocomplete="off" placeholder="### ###" />
				</li>
				<li>
					<label for=host>host</label>
					<input type=text id=host name=host value=localhost required />
				</li>
				<li>
					<label for=hostkey>hostkey</label>
					<input type=text id=hostkey name=hostkey />
				</li>
				<li>
					<label for=shell>shell</label>
					<input type=text id=shell name=shell placeholder=default />
				</li>
			</ul>
			<button>Connect</button>
			<input type=hidden id=CSRFToken value="{{.CSRF}}" />
		</form>
	</div>
</template>


<!--
	-- Login, connection, and terminal management.
	-->
<script nonce="{{.Nonce}}">
	"use strict"
	const login = () => {
		if (!document.querySelector("login-form") && crossOriginIsolated)
			document.body.appendChild(document.createElement("login-form"))
	}
	login()
	customElements.define("login-form", class extends HTMLElement {
		constructor() {
			super()
			if (location.protocol != 'https:') return // Ensure secure transport.
			this.attachShadow({mode: "open"}).appendChild(
				document.getElementById("-login-form").content.cloneNode(true))
		}
		connectedCallback() {
			if (!this.shadowRoot) return
			const loadURL = url => {
				// Update the form with URL parameter info on load.
				for (const [key, value] of new URL(url).searchParams.entries()) {
					const el = this.shadowRoot.querySelector("#" + key)
					if (el && el.nodeName == "INPUT") el.value = value
				}
			}
			window.onpopstate = (e) => loadURL(e.state)
			loadURL(window.location)
			// Hook up the login form submission process.
			this.shadowRoot.querySelector("form").addEventListener("submit", e => {
				// Saving updated form (safe) connection parameters to url.
				const saveURL = () => {
					var url = new URL(window.location)
					this.shadowRoot.querySelectorAll("input").forEach(i => {
						if (i.id == "CSRFToken") return
						if (i.id == "password") return
						if (i.id == "code") return
						url.searchParams.set(i.name, i.value)
					})
					if (window.location != url.href) {
						console.log("PUSHING")
						window.history.pushState(url.href, "", url.href)
					}
				}
				saveURL()
				this.shadowRoot.querySelector("button").classList.add("loading")
				e.preventDefault()
				// Establish WebSocket connection.
				fetch("/preconnect").then(() => {
					const ws = new WebSocket(`wss://${window.location.host}/connect`)
					var hostkeyfail = null
					// Process all websocket events in an ordered background queue.
					let msgQueue = Promise.resolve()
					const handshake = new Promise(ok => {
						const onmessage = async m => {
							const keyfield = this.shadowRoot.querySelector("#hostkey")
							const realkey = JSON.parse(m.data)
							if (realkey == "") {
								hostkeyfail = true
								ws.close()
							} else if (keyfield.value == "") keyfield.value = realkey
							ok()
						}
						ws.onmessage = m => msgQueue = msgQueue.then(() => onmessage(m))
					})
					const onclose = async () => {
						if (hostkeyfail) await warn(
							"⚠️ WARNING ⚠️\n" +
							"REMOTE HOST IDENTIFICATION HAS CHANGED!\n\n" +
							"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n" +
							"Host key verification failed.\n" +
							"Someone could be eavesdropping on you right now\n" +
							"(with an adversary-in-the-middle attack)!\n" +
							"It is also possible that a host key has just been changed.")
						location.reload(true)
					}
					ws.onclose = () => msgQueue = msgQueue.then(() => onclose())
					ws.onerror = () => msgQueue = msgQueue.then(() => onclose())
					// Process login flow and handshake.
					ws.onopen = async () => {
						// Authenticate WebSocket connection.
						ws.send(this.shadowRoot.querySelector("#CSRFToken").value)
						ws.send(this.shadowRoot.querySelector("#username").value)
						ws.send(this.shadowRoot.querySelector("#password").value)
						ws.send(this.shadowRoot.querySelector("#code").value)
						ws.send(this.shadowRoot.querySelector("#host").value)
						ws.send(this.shadowRoot.querySelector("#hostkey").value)
						ws.send(this.shadowRoot.querySelector("#shell").value)
						await handshake
						saveURL()
						// Give connection to the server API.
						if (!hostkeyfail) server.connect(ws)
					}
					document.body.removeChild(document.querySelector("login-form"))
				}).catch(() => location.reload())
			})
			this.shadowRoot.querySelector("#username").focus()
		}
	})

	const theme = {
		"background": "#181818", "foreground": "#d8d8d8", "cursorAccent": "#181818",
		"cursor": "#d8d8d8", "black": "#181818", "red": "#ac4242", "green": "#90a959",
		"yellow": "#f4bf75", "blue": "#6a9fb5", "magenta": "#aa759f", "cyan": "#75b5aa",
		"white": "#d8d8d8", "brightBlack": "#6b6b6b", "brightRed": "#c55555",
		"brightGreen": "#aac474", "brightYellow": "#feca88", "brightBlue": "#82b8c8",
		"brightMagenta": "#c28cb8", "brightCyan": "#93d3c3", "brightWhite": "#f8f8f8"
	}

	/**
	* Interface for all operations interacting with the server and server.
	* Securely manages server connection, with login and session management,
	* and only exposes the minimum interface.
	*/
	class Server {
		// Keep raw connections private, to limit javascript access.
		#ws = null; // websocket connection to the server.
		#onTermMsg = m => { }

		constructor() {
			// Setup the folder actions pane.
			// This is all nested inside the Server class to securly protect the terminal data streams.
			const stThis = this
			customElements.define("terminal-window", class extends HTMLElement {
				constructor() {
					super()
					this.attachShadow({mode: "open"}).appendChild(
						document.getElementById("-terminal-window").content.cloneNode(true))
				}
				connectedCallback() {
					const terminal = this.shadowRoot.getElementById("render")
					const term = new Terminal({
						fontFamily: terminal.style.fontFamily,
						fontSize: 12,
						theme: theme
					})
					const fitTerm = new window.FitAddon.FitAddon()
					term.loadAddon(fitTerm)
					term.open(terminal)
					window.onresize = () => {
						fitTerm.fit()
						// Resize the terminal pty session to the new rows and columns size.
						stThis.#ws.send(JSON.stringify({cols: term.cols, rows: term.rows}))
					}
					stThis.#onTermMsg = m => {
						if (m === null) {
							// Close terminal.
							term.dispose()
							stThis.#onTermMsg = m => { }
							window.onresize = null
							document.body.removeChild(this)
							location.reload(true)
						}
						else term.write(m)
					}
					term.attachCustomKeyEventHandler(e => {
						const mods = ((e.shiftKey ? 1 : 0) | (e.altKey ? 2 : 0) |
							(e.ctrlKey ? 4 : 0) | (e.metaKey ? 8 : 0))

						// XXX TODO clear this out custom handler if not used in this 2025 dev cycle.
						console.log(e)


						//return false
					})
					// Start streaming terminal input etc.
					term.onData(d => {stThis.#ws.send(new Blob([d]))})
					// Send start-session message.
					stThis.#ws.send(JSON.stringify({rows: -1}))
					window.onresize()
					term.focus()
				}
			})
		}

		/**
		 * Finalise the setup of the websocket connection,
		 */
		async connect(ws) {
			ws.onclose = () => {
				// close terminal if open.
				this.#onTermMsg(null)
				this.#onTermMsg = m => { }
				// Trigger a re-login prompt.
				location.reload(true)
			}
			window.onbeforeunload = () => ws.close() // Force logout ASAP
			ws.onerror = () => ws.close()
			// Setup normal message response handling.
			const onmessage = async m => {
				let id = null, v = null
				if (m.data instanceof Blob) {
					id = Number(await m.data.slice(0, 1).text())
					v = await m.data.slice(1)
				}
				// Send data to xtermjs or close.
				if (id === 1) this.#onTermMsg(new Uint8Array(await v.arrayBuffer()))
				else this.#onTermMsg(null) // Close terminal.
			}
			// Process all websocket messages in an ordered background queue.
			let msgQueue = Promise.resolve()
			ws.onmessage = m => msgQueue = msgQueue.then(() => onmessage(m)
			)
			this.#ws = ws
			// Connect terminal pane.
			document.body.appendChild(document.createElement("terminal-window"))
		}
	}
	const server = new Server();
</script>

<!--
	-- warn
	--
	-- Pop-up prompt for warnings.
	-->
<style nonce="{{.Nonce}}">
	.pop {
		position: fixed;
		z-index: 99;
		backdrop-filter: blur(18px);
		-webkit-backdrop-filter: blur(18px);
		background-color: rgba(255, 255, 255, 0.2);
		width: 100vw;
		height: 100vh;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		text-align: center;
		white-space: pre-line;
	}

	.pop button {
		font-size: 1.6em;
		border-style: solid;
		border-color: currentColor;
		float: right;
		margin: 5px;
		background-color: background;
	}
</style>
<template id=prompt>
	<div class=pop>
		<h1></h1>
		<p></p>
		<button id=ok>OK</button>
	</div>
</template>
<script nonce="{{.Nonce}}">
	"use strict"
	async function warn(msg) {
		const el = document.getElementById("prompt").content.cloneNode(true).querySelector(".pop")
		el.querySelector("h1").textContent = msg.substr(0, msg.indexOf("\n"))
		el.querySelector("p").textContent = msg.substr(msg.indexOf("\n") + 1)
		document.body.appendChild(el)
		el.querySelector("#ok").focus()
		await new Promise(ok => el.querySelector("#ok").onclick = () => ok())
		document.body.removeChild(el)
	}
</script>