<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="initial-scale=1, user-scalable=0, interactive-widget=resizes-content" />
<title>WebShuSH</title>
<link rel=stylesheet href="/resources/deps/xterm.css"
	integrity="sha384-LJcOxlx9IMbNXDqJ2axpfEQKkAYbFjJfhXexLfiRJhjDU81mzgkiQq8rkV0j6dVh" />
<script nonce="{{.Nonce}}">
	// Temporarily hide Macs from xtermjs loading to avoid it forcing Mac-style controls.
	// See: https://github.com/xtermjs/xterm.js/issues/4329
	_plt = navigator.platform
	navigator.__defineGetter__('platform', () => _plt.indexOf('Mac') == 0 ? 'nixLinux' : _plt)
</script>
<script src="/resources/deps/xterm.js"
	integrity="sha384-/nfmYPUzWMS6v2atn8hbljz7NE0EI1iGx34lJaNzyVjWGDzMv+ciUZUeJpKA3Glc"></script>
<script nonce="{{.Nonce}}">navigator.__defineGetter__('platform', () => _plt)</script>
<script src="/resources/deps/xterm-addon-fit.js"
	integrity="sha384-AQLWHRKAgdTxkolJcLOELg4E9rE89CPE2xMy3tIRFn08NcGKPTsELdvKomqji+DL"></script>
<style nonce="{{.Nonce}}">
	@font-face {
		font-family: NotoMonoNerd;
		src: url("/resources/NotoMonoNerdFontMono-Regular.ttf");
	}

	:root {
		color-scheme: light dark;
		--term-font: NotoMonoNerd;
	}

	* {
		font-family: system-ui, NotoMonoNerd;
	}

	body {
		/* UI pane with no page scrolling */
		position: fixed;
		margin: 0px;
		width: 100%;
		height: 100%;
		display: flex;
		overscroll-behavior: contain;
	}

	body>div>span {
		/* xtermjs font warmer fix so font width calculations are correct */
		font-family: var(--term-font);
	}
</style>

<body>
	<div><span><!-- xtermjs font warmer --></span></div>
</body>

<!--
	-- Terminal window.
	-->
<template id=-terminal-window>
	<style nonce="{{.Nonce}}">
		#render {
			position: fixed;
			left: 0px;
			top: 0px;
			width: 100%;
			height: 100%;
			font-family: var(--term-font);
		}
	</style>
	<link rel=stylesheet href="/resources/deps/xterm.css"
		integrity="sha384-LJcOxlx9IMbNXDqJ2axpfEQKkAYbFjJfhXexLfiRJhjDU81mzgkiQq8rkV0j6dVh" />
	<div id=render></div>
</template>

<!--
	-- Login form
	-->
<template id=-login-form>
	<style nonce="{{.Nonce}}">
		:host {
			position: fixed;
			z-index: 999999;
		}

		div {
			display: flex;
			width: 100vw;
			height: 100vh;
			align-items: center;
			justify-content: center;
		}

		ul {
			list-style: none;
		}

		li {
			margin: 3px;
		}

		label {
			display: inline-block;
			width: 80px;
			text-align: right;
		}

		input {
			padding: 5px;
		}

		button {
			float: right;
			font-size: 2em;
			border-style: solid;
			border-color: currentColor;
			background-color: background;
		}

		button.loading {
			filter: blur(3px);
		}
	</style>
	<div tabindex="-1">
		<form>
			<h1>ðŸ–¥ SSH</h1>
			<ul>
				<li>
					<label for=username>username</label>
					<input type=text id=username name=username required />
				</li>
				<li>
					<label for=password>password</label>
					<input type=password id=password name=password required />
				</li>
				<li>
					<label for=code></label>
					<input type=text id=code name=code title="2FA access code (optional on some servers)" size=6
						autocomplete="off" placeholder="### ###" />
				</li>
				<li>
					<label for=host>host</label>
					<input type=text id=host name=host value=localhost required />
				</li>
				<li>
					<label for=shell>shell</label>
					<input type=text id=shell name=shell placeholder=default />
				</li>
			</ul>
			<button>Connect</button>
			<input type=hidden id=CSRFToken value="{{.CSRF}}" />
		</form>
	</div>
</template>


<!--
	-- Login, connection, and terminal management.
	-->
<script nonce="{{.Nonce}}">
	"use strict"
	const login = () => {
		if (!document.querySelector("login-form") && crossOriginIsolated)
			document.body.appendChild(document.createElement("login-form"))
	}
	login()
	customElements.define("login-form", class extends HTMLElement {
		constructor() {
			super()
			if (location.protocol != 'https:') return // Ensure secure transport.
			this.attachShadow({mode: "open"}).appendChild(
				document.getElementById("-login-form").content.cloneNode(true))
		}
		connectedCallback() {
			if (!this.shadowRoot) return
			// Update the form with URL parameter info on load.
			for (const [key, value] of new URL(window.location).searchParams.entries()) {
				const el = this.shadowRoot.querySelector("#" + key)
				if (el && el.nodeName == "INPUT") el.value = value
			}
			// Hook up the login form submission process.
			this.shadowRoot.querySelector("form").addEventListener("submit", e => {
				// Save form (safe) connection parameters to url.
				this.shadowRoot.querySelectorAll("input").forEach(i => {
					if (i.id == "CSRFToken") return
					if (i.id == "password") return
					if (i.id == "code") return
					var url = new URL(window.location)
					url.searchParams.set(i.name, i.value)
					window.history.replaceState("", "", url.href)
				})
				this.shadowRoot.querySelector("button").classList.add("loading")
				e.preventDefault()
				// Establish WebSocket connection.
				fetch("/preconnect").then(() => {
					const ws = new WebSocket(`wss://${window.location.host}/connect`)
					ws.onclose = () => location.reload(true)
					ws.onerror = () => ws.close()
					ws.onopen = () => {
						// Authenticate WebSocket connection.
						ws.send(this.shadowRoot.querySelector("#CSRFToken").value)
						ws.send(this.shadowRoot.querySelector("#username").value)
						ws.send(this.shadowRoot.querySelector("#password").value)
						ws.send(this.shadowRoot.querySelector("#code").value)
						ws.send(this.shadowRoot.querySelector("#host").value)
						ws.send(this.shadowRoot.querySelector("#shell").value)
						// Give connection to the server API.
						server.connect(ws)
					}
					document.body.removeChild(document.querySelector("login-form"))
				}).catch(() => location.reload())
			})
			this.shadowRoot.querySelector("#username").focus()
		}
	})

	const theme = {
		"background": "#181818", "foreground": "#d8d8d8", "cursorAccent": "#181818",
		"cursor": "#d8d8d8", "black": "#181818", "red": "#ac4242", "green": "#90a959",
		"yellow": "#f4bf75", "blue": "#6a9fb5", "magenta": "#aa759f", "cyan": "#75b5aa",
		"white": "#d8d8d8", "brightBlack": "#6b6b6b", "brightRed": "#c55555",
		"brightGreen": "#aac474", "brightYellow": "#feca88", "brightBlue": "#82b8c8",
		"brightMagenta": "#c28cb8", "brightCyan": "#93d3c3", "brightWhite": "#f8f8f8"
	}

	/**
	* Interface for all operations interacting with the server and server.
	* Securely manages server connection, with login and session management,
	* and only exposes the minimum interface.
	*/
	class Server {
		// Keep raw connections private, to limit javascript access.
		#ws = null; // websocket connection to the server.
		#onTermMsg = m => { }

		constructor() {
			// Setup the folder actions pane.
			// This is all nested inside the Server class to securly protect the terminal data streams.
			const stThis = this
			customElements.define("terminal-window", class extends HTMLElement {
				constructor() {
					super()
					this.attachShadow({mode: "open"}).appendChild(
						document.getElementById("-terminal-window").content.cloneNode(true))
				}
				connectedCallback() {
					const terminal = this.shadowRoot.getElementById("render")
					const term = new Terminal({
						fontFamily: terminal.style.fontFamily,
						fontSize: 12,
						theme: theme
					})
					const fitTerm = new window.FitAddon.FitAddon()
					term.loadAddon(fitTerm)
					term.open(terminal)
					window.onresize = () => {
						fitTerm.fit()
						// Resize the terminal pty session to the new rows and columns size.
						stThis.#ws.send(JSON.stringify({cols: term.cols, rows: term.rows}))
					}
					stThis.#onTermMsg = m => {
						if (m === null) {
							// Close terminal.
							term.dispose()
							stThis.#onTermMsg = m => { }
							window.onresize = null
							document.body.removeChild(this)
							location.reload(true)
						}
						else term.write(m)
					}
					term.attachCustomKeyEventHandler(e => {
						console.log(e)
						const mods = ((e.shiftKey ? 1 : 0) | (e.altKey ? 2 : 0) |
							(e.ctrlKey ? 4 : 0) | (e.metaKey ? 8 : 0))




						//return false
					})
					// Start streaming terminal input etc.
					term.onData(d => {stThis.#ws.send(new Blob([d]))})
					// Send start-session message.
					stThis.#ws.send(JSON.stringify({rows: -1}))
					window.onresize()
					term.focus()
				}
			})
		}

		/**
		 * Finalise the setup of the websocket connection,
		 */
		async connect(ws) {
			ws.onclose = () => {
				// close terminal if open.
				this.#onTermMsg(null)
				this.#onTermMsg = m => { }
				// Trigger a re-login prompt.
				location.reload(true)
			}
			window.onbeforeunload = () => ws.close() // Force logout ASAP
			ws.onerror = () => ws.close()
			// Setup normal message response handling.
			const onmessage = async m => {
				let id = null, v = null
				if (m.data instanceof Blob) {
					id = Number(await m.data.slice(0, 1).text())
					v = await m.data.slice(1)
				}
				// Send data to xtermjs or close.
				if (id === 1) this.#onTermMsg(new Uint8Array(await v.arrayBuffer()))
				else this.#onTermMsg(null) // Close terminal.
			}
			// Process all websocket messages in an ordered background queue.
			let msgQueue = Promise.resolve()
			ws.onmessage = m => msgQueue = msgQueue.then(() => onmessage(m)
			)
			this.#ws = ws
			// Connect terminal pane.
			document.body.appendChild(document.createElement("terminal-window"))
		}
	}
	const server = new Server();
</script>